# Scoreboard & Scoring Module

## Overview

This module handles secure score ingestion and real-time leaderboard broadcasting (Top 10). It utilizes **Redis Sorted Sets** for high-performance ranking and **WebSockets** for live client updates.

## Tech Stack

* **Storage:** Redis (Sorted Sets), PostgreSQL (Persistence).
* **Transport:** REST (Ingestion), WebSockets (Broadcasting).
* **Auth:** JWT (User Identity).

## API Specifications

### 1. Score Ingestion

**Endpoint:** `POST /api/score/update`
**Headers:** `Authorization: Bearer <JWT>`

**Payload:**

```json
{
  "actionId": "uuid-v4",
  "actionSignature": "hmac_sha256_string",
  "points": 100
}
```

**Logic:**

1. **Auth:** Verify JWT validity.
2. **Anti-Cheat:** Verify `actionSignature` (ensures the action was legitimately generated by the client logic and not a replay).
3. **Update:** * Increment user score in Redis: `ZINCRBY global_leaderboard 100 <userId>`
* Insert record into SQL `score_logs` table for audit.


4. **Trigger:** Emit event `LEADERBOARD_UPDATED`.

### 2. Live Leaderboard Stream

**Protocol:** WebSocket / Server-Sent Events (SSE)
**Channel:** `public:leaderboard`

**Payload (Broadcasted on Change):**

```json
{
  "timestamp": 1704529000,
  "top_10": [
    {"rank": 1, "username": "playerOne", "score": 5000},
    {"rank": 2, "username": "playerTwo", "score": 4850}
    // ... up to 10
  ]
}
```

## Security Implementation

* **Rate Limiting:** Max 1 score update per X seconds per user (Redis Token Bucket).
* **Action Signing:** The client must generate a signature for the action using a rotating secret or server-generated nonce to prevent API replay attacks (using cURL to spam the endpoint).

---

### 3. Comments for Improvement

* **Optimistic UI:** The client should update the user's local score immediately for a snappy feel, but roll it back if the API returns a 400/403 error.
* **Throttling Broadcasts:** If traffic is high, do not broadcast on *every* single score update. Use a "debounce" mechanism (e.g., broadcast the state of the leaderboard max once every 500ms) to save bandwidth.
* **Action Validation:** Relying solely on a client API call is insecure. Ideally, the "Action" logic should move to the server, or the completion of the action should generate a one-time-use server-signed token that must be included in the `POST` request.
